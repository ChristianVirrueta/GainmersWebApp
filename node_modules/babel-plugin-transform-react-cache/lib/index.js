module.exports = function(babel) {
    var t = babel.types;

    return {
        visitor: {
            CallExpression: function(path) {
                const cacheProperty = calleeDoesMatch(t, path.node.callee)
                              && argumentMatch(t, path.node.arguments);

                if (!!cacheProperty) {
                    replacePath(t, path, cacheProperty);
                }
            }
        }
    };
};

function calleeDoesMatch(t, callee) {

    return t.isMemberExpression(callee)
        && t.isIdentifier(callee.object, { name: 'React' })
        && t.isIdentifier(callee.property, { name: 'createElement' });
}

function argumentMatch(t, nodeArguments) {
    const config = (nodeArguments || [])[1];

    if (t.isCallExpression(config)) {
        // <Component propA={...} propB={...} {...otherProps} />
        const configArguments = config.arguments;
        for (var i = 0; i < configArguments.length; i++) {
            const argument = configArguments[i];
            // <Component propA={...} propB={...} />
            if (t.isObjectExpression(argument)) {
                return propertiesMatch(t, argument);
            }
            if (t.isIdentifier(argument)) {
                // <Component {...otherProps} />
                // check scope to resolve otherProps key/value pairs
                // const variableName = argument.name;
            }
        }
    }

    if (t.isObjectExpression(config)) {
        // React.createElement(type, config, children)
        return propertiesMatch(t, config);
    }
}

function propertiesMatch(t, object) {
    const properties = object.properties || [];    
    return properties.reduce((last, p) => last || propertyMatch(t, p), undefined);
}

function propertyMatch(t, property) {
    if (t.isObjectProperty(property)
     && t.isIdentifier(property.key, { name: 'cache' })) {

        return cachePropertyMatch(t, property.value);
    }
}

function cachePropertyMatch(t, value) {

    if (t.isFunction(value)) {
        return {
            value
        };
    }
}

function replacePath(t, path, cacheProperty) {

    const fPath = getFirstFunctionAncestorPath(t, path);
    
    if (!fPath) {
        return;
    }

    const cacheIdentifier = path.scope.generateUidIdentifierBasedOnNode(path.node.id);

    const variableDeclaration = t.variableDeclaration('var', [
        t.variableDeclarator(cacheIdentifier, cacheProperty.value)
    ]);
    variableDeclaration._reactCacheHoisted = true;

    if (isAlreadyHoisted(t, fPath, cacheIdentifier)) {
        addVariableIntoFunction(t, fPath, variableDeclaration);
    } else {
        hoistVariableIntoFunction(t, fPath, variableDeclaration);
    }

    replaceElementPath(t, path, cacheIdentifier);    
}


function getFirstFunctionAncestorPath(t, path) {
    var p = path;
    while(p && !t.isFunction(p.node)) {
        p = p.parentPath;
    }
    return p;
}

function isAlreadyHoisted(t, path, cacheIdentifier) {
    const container = path.parentPath.container;
    return container.constructor === Array 
           && !!container
               .filter(node => t.isVariableDeclaration(node) && node._reactCacheHoisted)
               .length;
}

function hoistVariableIntoFunction(t, path, variableDeclaration) {
    path.replaceWith(t.callExpression(
        t.functionExpression(
            null,
            [],
            t.blockStatement([
                variableDeclaration,
                t.returnStatement(
                    t.FunctionExpression(
                        null, 
                        path.node.params, 
                        path.node.body
                    )
                )
            ])
        ),
        []
    ));
}

function addVariableIntoFunction(t, path, variableDeclaration) {
    path.parentPath.insertBefore(variableDeclaration);
}

function replaceElementPath(t, path, cacheIdentifier) {

    const args = path.node.arguments;
    const props = path.node.arguments[1];
    const properties = props && props.properties || [];
    const propertiesToPass = properties.filter(p => !t.isIdentifier(p.key, { name: 'cache' }));

    path.replaceWith(t.callExpression(
        t.callExpression(
            t.memberExpression(
                t.identifier('ReactCache'), 
                t.identifier('createElement')
            ),
            [cacheIdentifier]
        ),
        [
            args[0], 
            t.objectExpression(propertiesToPass)
        ].concat(args[2] ? args[2] : [])
    ));
}
